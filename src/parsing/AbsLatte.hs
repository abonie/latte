

module AbsLatte where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Program a [TopDef a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a topdefs -> Program (f a) (map (fmap f) topdefs)
data TopDef a
    = FnDef a (FunDef a) | ClsDef a Ident (Ext a) (CBody a)
  deriving (Eq, Ord, Show, Read)

instance Functor TopDef where
    fmap f x = case x of
        FnDef a fundef -> FnDef (f a) (fmap f fundef)
        ClsDef a ident ext cbody -> ClsDef (f a) ident (fmap f ext) (fmap f cbody)
data Ext a = ExtSome a Ident | ExtNone a
  deriving (Eq, Ord, Show, Read)

instance Functor Ext where
    fmap f x = case x of
        ExtSome a ident -> ExtSome (f a) ident
        ExtNone a -> ExtNone (f a)
data FunDef a = FunDef a (Type a) Ident [Arg a] (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor FunDef where
    fmap f x = case x of
        FunDef a type_ ident args block -> FunDef (f a) (fmap f type_) ident (map (fmap f) args) (fmap f block)
data Arg a = Arg a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Arg where
    fmap f x = case x of
        Arg a type_ ident -> Arg (f a) (fmap f type_) ident
data CBody a = CBody a [MemDecl a]
  deriving (Eq, Ord, Show, Read)

instance Functor CBody where
    fmap f x = case x of
        CBody a memdecls -> CBody (f a) (map (fmap f) memdecls)
data MemDecl a = MemVar a (Type a) [Ident] | MemFun a (FunDef a)
  deriving (Eq, Ord, Show, Read)

instance Functor MemDecl where
    fmap f x = case x of
        MemVar a type_ idents -> MemVar (f a) (fmap f type_) idents
        MemFun a fundef -> MemFun (f a) (fmap f fundef)
data Block a = Block a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        Block a stmts -> Block (f a) (map (fmap f) stmts)
data Stmt a
    = Empty a
    | BStmt a (Block a)
    | Decl a (Type a) [Item a]
    | Ass a (LHS a) (Expr a)
    | Incr a (LHS a)
    | Decr a (LHS a)
    | Ret a (Expr a)
    | VRet a
    | Cond a (Expr a) (Stmt a)
    | CondElse a (Expr a) (Stmt a) (Stmt a)
    | While a (Expr a) (Stmt a)
    | SExp a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        Empty a -> Empty (f a)
        BStmt a block -> BStmt (f a) (fmap f block)
        Decl a type_ items -> Decl (f a) (fmap f type_) (map (fmap f) items)
        Ass a lhs expr -> Ass (f a) (fmap f lhs) (fmap f expr)
        Incr a lhs -> Incr (f a) (fmap f lhs)
        Decr a lhs -> Decr (f a) (fmap f lhs)
        Ret a expr -> Ret (f a) (fmap f expr)
        VRet a -> VRet (f a)
        Cond a expr stmt -> Cond (f a) (fmap f expr) (fmap f stmt)
        CondElse a expr stmt1 stmt2 -> CondElse (f a) (fmap f expr) (fmap f stmt1) (fmap f stmt2)
        While a expr stmt -> While (f a) (fmap f expr) (fmap f stmt)
        SExp a expr -> SExp (f a) (fmap f expr)
data Item a = NoInit a Ident | Init a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Item where
    fmap f x = case x of
        NoInit a ident -> NoInit (f a) ident
        Init a ident expr -> Init (f a) ident (fmap f expr)
data LHS a
    = LhsVar a Ident | LhsMem a Ident Ident | LhsInd a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor LHS where
    fmap f x = case x of
        LhsVar a ident -> LhsVar (f a) ident
        LhsMem a ident1 ident2 -> LhsMem (f a) ident1 ident2
        LhsInd a ident expr -> LhsInd (f a) ident (fmap f expr)
data Type a
    = Scalar a (SType a) | Array a (AType a) | Fun a (Type a) [Type a]
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        Scalar a stype -> Scalar (f a) (fmap f stype)
        Array a atype -> Array (f a) (fmap f atype)
        Fun a type_ types -> Fun (f a) (fmap f type_) (map (fmap f) types)
data AType a = Arr a (SType a)
  deriving (Eq, Ord, Show, Read)

instance Functor AType where
    fmap f x = case x of
        Arr a stype -> Arr (f a) (fmap f stype)
data SType a = Int a | Str a | Bool a | Void a | TCls a Ident
  deriving (Eq, Ord, Show, Read)

instance Functor SType where
    fmap f x = case x of
        Int a -> Int (f a)
        Str a -> Str (f a)
        Bool a -> Bool (f a)
        Void a -> Void (f a)
        TCls a ident -> TCls (f a) ident
data Expr a
    = EVar a Ident
    | EMem a Ident Ident
    | EInd a Ident (Expr a)
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | ENew a Ident
    | ENull a Ident
    | EArr a (Type a) (Expr a)
    | EApp a Ident [Expr a]
    | EMet a Ident Ident [Expr a]
    | EString a String
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        EMem a ident1 ident2 -> EMem (f a) ident1 ident2
        EInd a ident expr -> EInd (f a) ident (fmap f expr)
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        ENew a ident -> ENew (f a) ident
        ENull a ident -> ENull (f a) ident
        EArr a type_ expr -> EArr (f a) (fmap f type_) (fmap f expr)
        EApp a ident exprs -> EApp (f a) ident (map (fmap f) exprs)
        EMet a ident1 ident2 exprs -> EMet (f a) ident1 ident2 (map (fmap f) exprs)
        EString a string -> EString (f a) string
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)

-- End of code generated by BNFC, some utility stuff below:

type PosInfo = Maybe (Int, Int)

nopos :: PosInfo
nopos = Nothing

rmpos :: Type a -> Type PosInfo
rmpos = (nopos <$)

type PProgram = Program PosInfo
type PTopDef = TopDef PosInfo
type PArg = Arg PosInfo
type PBlock = Block PosInfo
type PStmt = Stmt PosInfo
type PItem = Item PosInfo
type PType = Type PosInfo
type PExpr = Expr PosInfo
type PAddOp = AddOp PosInfo
type PMulOp = MulOp PosInfo
type PRelOp = RelOp PosInfo

pInt  = Scalar nopos $ Int nopos
pStr  = Scalar nopos $ Str nopos
pBool = Scalar nopos $ Bool nopos
pVoid = Scalar nopos $ Void nopos
pFun = Fun nopos
